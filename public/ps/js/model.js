/* ============================================================
   MODEL
   ============================================================ */

const DEFAULT_INPUT = {
  contextText: `Context: Progress across LifeFocus → Goals → Tasks feels opaque.
Trigger: Too many parallel goals; inconsistent scoring; no ritual.
Conflict: Work happens but narrative & metrics are not captured.
Constraints: Protect mornings; cap active goals; avoid scope creep.
Stakeholders: You, Future-you reviewer, Delegates.
Goal: Build a single-file dashboard + reasoning workbench that converts language into structured execution.`,
  tasksText: `Ship interactive SCQA editor
Add 5-Whys builder
Generate MECE issue tree nodes
Add MoSCoW + Eisenhower prioritizer
Create task execution helper: next action, blockers, timebox
Auto-generate narrative, report, story, comic beats from tasks
Implement scoring: TW, CP, SM, ESF, QM, SF, BP -> BPS/APS/SPS`
};

const SAMPLE = {
  period: { id: "Q1-2026", label: "Q1", start: "2026-01-01", end: "2026-03-31" },
  rawInput: {
    contextText: "", // Start empty to force "Default Example" mode
    tasksText: ""
  },
  // Phase 0
  definitions: [],
  claims: [],
  scqa: {
    situation: "", conflict: "", question: "", answer: "",
    constraints: { time: "", quality: "", quantity: "", budgetUSD: 200, stakeholders: [] },
    hypotheses: [],
    assertions: []
  },
  fiveWhys: {
    chain: ["", "", "", "", ""],
    rootCause: "",
    fixIdea: ""
  },
  fishbone: { categories: [] },
  meceTree: {
    root: { id: "N-ROOT", label: "Problem System", kind: "issue", note: "", children: [] }
  },
  priorities: {
    moscow: { must: [], should: [], could: [], wont: [] },
    eisenhower: { ui: [], un: [], ni: [], nn: [] } // urgent+important, urgent+not, not+important, not+not
  },
  tasks: [],
  scoringDefaults: {
    SM: 1.1, ESF: 1.0, QM: 1.1, SF: 1.0, BP: 0.0
  },
  outputs: {
    narrative: "",
    report: "",
    story: "",
    comic: "",
    brief: "",
    meeting: "",
    caseReport: ""
  },
  lifeFocus: [
    { code: "F01", focus: "CORE", score: 78 },
    { code: "F02", focus: "SELF", score: 63 },
    { code: "F03", focus: "CIRCLE", score: 58 },
    { code: "F04", focus: "GRIND", score: 71 },
    { code: "F05", focus: "LEVEL UP", score: 66 },
    { code: "F06", focus: "IMPACT", score: 44 },
    { code: "F07", focus: "PLAY", score: 52 },
    { code: "F08", focus: "INSIGHT", score: 74 },
    { code: "F09", focus: "CHAOS", score: 35 }
  ],
  _meta: { lastRunAt: null, version: "v2-workbench" }
};

let MODEL = deepClone(SAMPLE);

function deepClone(x) { return JSON.parse(JSON.stringify(x)); }
function uid(prefix = "X") { return prefix + "-" + Math.random().toString(16).slice(2, 8).toUpperCase(); }
function clamp(n, a, b) { return Math.max(a, Math.min(b, n)); }
function nowStr() { return new Date().toLocaleString(); }
function debounce(func, wait) {
  let timeout;
  return function (...args) {
    const context = this;
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(context, args), wait);
  };
}

/* ============================================================
   PIPELINE
   ============================================================ */

function runPipeline() {
  runParseInput();
  runGeneration();
}

function runParseInput() {
  // Parse SCQA from Raw Input OR Default
  if (MODEL.rawInput.contextText) {
    MODEL.scqa = parseContextToSCQA(MODEL.rawInput.contextText);
  } else {
    // Fallback to default example if input is empty
    MODEL.scqa = parseContextToSCQA(DEFAULT_INPUT.contextText);
  }

  // Parse Tasks from Raw Input OR Default
  if (MODEL.rawInput.tasksText && MODEL.rawInput.tasksText.trim().length > 0) {
    const userTasks = parseTasks(MODEL.rawInput.tasksText);
    // If parsing resulted in 0 tasks (e.g. just comments or blank lines), fallback?
    // Actually, user might WANT 0 tasks. But for "autogenerated" feel, maybe heuristic?
    // Let's just trust the parser. If they typed text, they meant it.
    // BUT, if they cleared the field, we want DEFAULT.
    MODEL.tasks = userTasks;
  } else {
    MODEL.tasks = parseTasks(DEFAULT_INPUT.tasksText);
  }

  // Always score tasks
  MODEL.tasks.forEach(t => computeTaskScore(t));
}

function runGeneration() {
  // Use MODEL directly (it now contains either User or Default data)

  // Prioritize
  MODEL.priorities = prioritizeTasks(MODEL.tasks);

  // Generate Outputs
  MODEL.outputs.narrative = genTaskNarrative(MODEL.tasks[0] || { title: "No Item", blockers: [] }, MODEL.scqa);
  MODEL.outputs.report = (MODEL.tasks[0]) ? genTaskReport(MODEL.tasks[0]) : "No tasks.";
  MODEL.outputs.story = genTaskStory(MODEL.tasks[0] || { title: "Quest", blockers: [], nextAction: "Start" }, MODEL.scqa);
  MODEL.outputs.comic = genTaskComic(MODEL.tasks[0] || { title: "Mission", nextAction: "Begin", doneDefinition: "Done" });
  MODEL.outputs.brief = genBrief(MODEL.scqa, MODEL.tasks);
  MODEL.outputs.meeting = genMeeting(MODEL.scqa, MODEL.tasks);
  MODEL.outputs.caseReport = genCaseReport(MODEL.scqa, MODEL.fiveWhys, MODEL.fishbone, MODEL.priorities, MODEL.tasks, MODEL.meceTree);

  // Auto-generate Task from 5 Whys Fix Idea?
  if (MODEL.fiveWhys.fixIdea && MODEL.fiveWhys.fixIdea !== "Fix idea placeholder") {
    const fixTitle = `Fix: ${MODEL.fiveWhys.fixIdea}`;
    const exists = MODEL.tasks.some(t => t.title === fixTitle);
    if (!exists) {
      MODEL.tasks.unshift({
        id: uid("T"), title: fixTitle,
        status: "Not Started", priority: 1, due: "", estimateMin: 60, confidence: 0.8,
        owner: "Auto-Gen", blockers: [], nextAction: "Validate fix", doneDefinition: "Root cause eliminated",
        narrative: "", report: "", story: "", comic: "",
        score: { TW: 8, CP: 0, SM: 1, ESF: 1, QM: 1, SF: 1, BP: 0, BPS: 0, APS: 0, SPS: 0 },
        tags: ["auto", "fix"]
      });
      computeTaskScore(MODEL.tasks[0]);
    }
  }

  // Build tree
  MODEL.meceTree = buildIssueTree(MODEL.scqa, MODEL.fiveWhys, MODEL.tasks);

  // Build fishbone
  // Note: we don't want to overwrite manual fishbone edits if they exist.
  // But for now, we only regenerate if empty? No, let's leave it manual-first in hydrate.
  // Actually, runGeneration should probably NOT overwrite Fishbone if it's being edited manually.
  // The user edits MODEL.fishbone directly in the view.
  if (!MODEL.fishbone.categories.length) {
    MODEL.fishbone = buildFishbone(MODEL.scqa);
  }

  MODEL._meta.lastRunAt = nowStr();
}

/* ============================================================
   LANGUAGE PARSING (NLP & HEURISTICS)
   ============================================================ */

const NLP = {
  // Regex patterns for classification
  patterns: {
    conflict: /\b(issue|problem|fail|broken|crash|bug|error|slow|latency|leak|stuck|blocked|hard|difficult|annoying|pain|mess|opaque|chaos)\b/i,
    goal: /\b(goal|objective|target|vision|aim|must|should|want|need to|achieve|enable)\b/i,
    question: /\?$/,
    task: /^(?:I need to|We must|Please|Fix|Ship|Build|Create|Add|Update|Remove|Refactor|Optimize|Deploy|Test|Verify|Check)\b/i,
    constraint: /\b(limit|cap|budget|cost|time|deadline|only|restrict|constraint|boundary)\b/i,
    stakeholder: /\b(client|user|customer|boss|manager|team|reviewer|exec|stakeholder)\b/i,

    // Entity extraction
    date: /\b(?:by|due|on|until)?\s*((?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)[a-z]*\.?\s+\d{1,2}(?:st|nd|rd|th)?(?:,?\s+\d{4})?|\d{1,2}\/\d{1,2}(?:\/\d{2,4})?|\d{4}-\d{2}-\d{2}|tomorrow|next week|friday|monday)\b/i,
    priority: /\b(urgent|critical|high|asp|asap|important|p0|p1)\b/i,
    money: /\$?\d+(?:,\d{3})*(?:\.\d+)?\s*(?:usd|dollars|k|m)/i
  },

  segment(text) {
    text = String(text || "").trim();
    if (!text) return [];

    // Use Intl.Segmenter if available (modern browsers)
    if (typeof Intl !== 'undefined' && Intl.Segmenter) {
      const segmenter = new Intl.Segmenter('en', { granularity: 'sentence' });
      return Array.from(segmenter.segment(text)).map(s => s.segment.trim()).filter(Boolean);
    }

    // Robust fallback
    return text.split(/([.?!])\s+(?=[A-Z])/).reduce((acc, part, i, arr) => {
      if (i % 2 === 0) { // Content
        const punct = arr[i + 1] || "";
        if (part) acc.push((part + punct).trim());
      }
      return acc;
    }, []);
  },

  classify(sentence) {
    const s = sentence.toLowerCase();

    // 1. Explicit overrides (colon syntax) still win
    if (s.match(/^(context|situation):/)) return "situation_override";
    if (s.match(/^(conflict|issue|problem):/)) return "conflict_override";
    if (s.match(/^(goal|objective):/)) return "goal_override";
    if (s.match(/^(task|todo):/)) return "task_override";

    // 2. Heuristics
    let score = { situation: 1, conflict: 0, goal: 0, task: 0, question: 0 };

    if (NLP.patterns.conflict.test(s)) score.conflict += 2;
    if (NLP.patterns.goal.test(s)) score.goal += 2;
    if (NLP.patterns.question.test(s)) score.question += 3;
    if (NLP.patterns.constraint.test(s)) score.situation += 1; // constraints often part of context

    // Imperative verbs often signal tasks
    if (NLP.patterns.task.test(sentence)) score.task += 2;

    // Sentiment adjustments (crude)
    if (s.includes("not") || s.includes("no ") || s.includes("fail")) score.conflict += 0.5;
    if (s.includes("will") || s.includes("can")) score.goal += 0.5;

    // Find winner
    const max = Math.max(score.situation, score.conflict, score.goal, score.task, score.question);
    if (max === score.question) return "question";
    if (max === score.task && score.task > 1) return "task";
    if (max === score.conflict && score.conflict > 1) return "conflict";
    if (max === score.goal && score.goal > 1) return "goal";

    return "situation"; // Default to general context
  },

  extractAttributes(text) {
    const dateMatch = text.match(NLP.patterns.date);
    const priMatch = text.match(NLP.patterns.priority);
    const moneyMatch = text.match(NLP.patterns.money);

    return {
      due: dateMatch ? dateMatch[1] : "",
      priority: priMatch ? (priMatch[1].match(/p0|urgent|critical/i) ? 1 : 2) : 3,
      budget: moneyMatch ? parseFloat(moneyMatch[0].replace(/[^0-9.]/g, '')) : 0
    };
  }
};

function parseContextToSCQA(text) {
  const sentences = NLP.segment(text);

  const out = {
    situation: [],
    conflict: [],
    question: [],
    answer: [],
    constraints: { time: "", quality: "", quantity: "", budgetUSD: 200, stakeholders: [] },
    hypotheses: [],
    assertions: []
  };

  const rawConstraints = [];
  const rawStakeholders = [];

  sentences.forEach(s => {
    const type = NLP.classify(s);

    // Handle explicit overrides first
    if (type.includes("_override")) {
      const content = s.replace(/^[^:]+:\s*/, "");
      if (type === "conflict_override") out.conflict.push(content);
      else if (type === "goal_override") out.answer.push(`Goal: ${content}`);
      else out.situation.push(content);
      return;
    }

    // Heuristic routing
    switch (type) {
      case "conflict": out.conflict.push(s); break;
      case "question": out.question.push(s); break;
      case "goal": out.answer.push(`Obj: ${s}`); break;
      default: out.situation.push(s); break;
    }

    // Constraint sniffing (global pass)
    if (NLP.patterns.constraint.test(s)) rawConstraints.push(s);
    if (NLP.patterns.stakeholder.test(s)) rawStakeholders.push(s);
  });

  // Synthesize strings
  const finalS = out.situation.join(" ");
  const finalC = out.conflict.join(" ");
  const finalQ = out.question.length ? out.question.join(" ") : (finalC ? "How do we resolve this conflict?" : "What is the best path forward?");
  const finalA = out.answer.join(" ");

  // Fill object
  const result = {
    situation: finalS || "Context provided.",
    conflict: finalC || "No explicit conflict detected.",
    question: finalQ,
    answer: finalA || "Proposed solution strategy.",
    constraints: {
      time: sniffConstraint(rawConstraints.join(" "), ["time", "deadline", "date"]) || "",
      quality: sniffConstraint(rawConstraints.join(" "), ["quality", "standard"]) || "",
      quantity: sniffConstraint(rawConstraints.join(" "), ["limit", "cap", "scope"]) || "",
      budgetUSD: NLP.extractAttributes(text).budget || 200,
      stakeholders: rawStakeholders.length ? [...new Set(splitList(rawStakeholders.join(", ")))] : []
    },
    hypotheses: [
      { id: uid("H"), h: "If we address the root conflict, metrics will improve.", confidence: 0.6 }
    ],
    assertions: []
  };

  return result;
}

function parseTasks(text) {
  // 1. Split by newlines for bullet points (explicit)
  const lines = String(text || "").split(/\n+/).map(x => x.trim()).filter(Boolean);

  // 2. Also split prose logic if present (implicit tasks in paragraphs)
  // Heuristic: If lines look like paragraphs (>80 chars), try segmenting them too.
  const taskCandidates = [];
  lines.forEach(line => {
    if (line.length > 80 && line.includes(".")) {
      const segs = NLP.segment(line);
      segs.forEach(s => {
        if (NLP.classify(s) === "task") taskCandidates.push(s);
      });
    } else {
      taskCandidates.push(line);
    }
  });

  const tasks = taskCandidates.map((ln) => {
    const id = uid("T");
    const attr = NLP.extractAttributes(ln);
    const cleanTitle = normalizeTaskTitle(ln);

    const impact = guessImpact(cleanTitle);

    return {
      id,
      title: cleanTitle,
      status: "Not Started",
      priority: attr.priority,
      due: attr.due,
      estimateMin: guessEffort(cleanTitle),
      impact,
      confidence: 0.6,
      owner: "You",
      blockers: [],
      nextAction: "",
      doneDefinition: "",
      narrative: "",
      report: "",
      story: "",
      score: {
        TW: clamp(Math.round(impact * 10), 0, 10),
        CP: 0.0,
        SM: MODEL.scoringDefaults.SM,
        ESF: MODEL.scoringDefaults.ESF,
        QM: MODEL.scoringDefaults.QM,
        SF: MODEL.scoringDefaults.SF,
        BP: MODEL.scoringDefaults.BP,
        BPS: 0,
        APS: 0,
        SPS: 0
      },
      tags: guessTags(cleanTitle)
    };
  });

  return tasks;
}

// Helpers reused by new logic
function splitList(s) {
  s = String(s || "").trim();
  if (!s) return [];
  // enhanced splitter
  return s.split(/[,;]|\s+and\s+/i).map(x => x.trim()).filter(Boolean);
}

function sniffConstraint(s, words) {
  const t = String(s || "").toLowerCase();
  for (const w of words) {
    if (t.includes(w.toLowerCase())) return s.trim(); // Return full sentence context for now
  }
  return "";
}

function normalizeTaskTitle(s) {
  s = String(s || "").trim();
  s = s.replace(/^[-*•>]\s*/, ""); // Remove bullets
  s = s.replace(/^\d+\.\s*/, ""); // Remove numbering
  return s.replace(/\s+/g, " ");
}

function guessEffort(s) {
  const t = String(s || "").toLowerCase();
  if (t.includes("score") || t.includes("architect")) return 180;
  if (t.includes("design") || t.includes("plan")) return 90;
  if (t.includes("test") || t.includes("fix")) return 45;
  return 60;
}

function guessImpact(s) {
  const t = String(s || "").toLowerCase();
  if (t.includes("critical") || t.includes("core")) return 0.9;
  if (t.includes("feature") || t.includes("user")) return 0.8;
  if (t.includes("doc") || t.includes("style")) return 0.4;
  return 0.6;
}

function guessTags(s) {
  const t = String(s || "").toLowerCase();
  const tags = [];
  if (t.includes("fix") || t.includes("bug")) tags.push("bug");
  if (t.includes("test")) tags.push("qa");
  if (t.includes("design")) tags.push("design");
  if (t.includes("perf") || t.includes("fast")) tags.push("performance");
  return tags;
}

/* ============================================================
   5 WHYS + MECE TREE + FISHBONE (Structure)
   ============================================================ */

function buildFiveWhysFromSCQA(scqa) {
  const c = (scqa.conflict || "").trim();
  const s = (scqa.situation || "").trim();
  const seed = c || s || "Progress is not improving.";
  const chain = [
    `Why does "${seed}" occur?`,
    `Why does the above cause exist?`,
    `Why is that?`,
    `Why?`,
    `Why?`
  ];
  return { chain, rootCause: "Root cause placeholder", fixIdea: "Fix idea placeholder" };
}

// Enhanced Issue Tree Builder based on MECE principles
function buildIssueTree(scqa, fiveWhys, tasks) {
  // ROOT: The Core Question/Conflict
  const rootLabel = scqa.question ? scqa.question : (scqa.conflict ? `How to resolve: ${scqa.conflict.substring(0, 30)}...` : "Core Problem");

  const root = {
    id: "N-ROOT",
    label: rootLabel,
    kind: "root",
    note: "The Primary Question to Answer",
    children: []
  };

  // BRANCH 1: SITUATION (Context)
  const sitNode = node("Situation", "context", "Current State / Context", []);
  if (scqa.situation) {
    const sentences = NLP.segment(scqa.situation);
    if (sentences.length > 0) {
      // Use the actual sentence as the label, truncated for display
      sitNode.children = sentences.slice(0, 4).map((s, i) => {
        const shortLabel = s.length > 25 ? s.substring(0, 22) + "..." : s;
        return node(shortLabel, "context", s);
      });
    } else {
      sitNode.children.push(node("Details", "context", scqa.situation));
    }
  }
  root.children.push(sitNode);

  // BRANCH 2: DIAGNOSIS (Framework-Driven)
  // Detect intent to pick the right framework
  const text = (rootLabel + " " + (scqa.situation || "")).toLowerCase();
  let diagNode = node("Diagnosis", "hypothesis", "Framework Analysis", []);

  if (text.includes("profit") || text.includes("revenue") || text.includes("loss") || text.includes("margin") || text.includes("cost")) {
    // PROFITABILITY FRAMEWORK
    diagNode.label = "Profitability Driver";
    diagNode.children = [
      node("Revenue", "hypothesis", "Price x Volume", [
        node("Price", "hypothesis", "Elasticity?"),
        node("Volume", "hypothesis", "Market Size/Share?")
      ]),
      node("Costs", "hypothesis", "Fixed + Variable", [
        node("Fixed", "hypothesis", "Rent, Overhead"),
        node("Variable", "hypothesis", "COGS, Labor")
      ])
    ];
  } else if (text.includes("market") && (text.includes("enter") || text.includes("entry") || text.includes("expansion"))) {
    // MARKET ENTRY FRAMEWORK
    diagNode.label = "Market Entry";
    diagNode.children = [
      node("Market Viability", "hypothesis", "Is it attractive?", [
        node("Size & Growth", "hypothesis"),
        node("Competition", "hypothesis")
      ]),
      node("Financials", "hypothesis", "Can we make money?", [
        node("Pricing", "hypothesis"),
        node("Costs", "hypothesis")
      ]),
      node("Capabilities", "hypothesis", "Can we win?", [
        node("Supply Chain", "hypothesis"),
        node("Brand", "hypothesis")
      ])
    ];
  } else if (text.includes("acquisition") || text.includes("merger") || text.includes("buy")) {
    // M&A FRAMEWORK
    diagNode.label = "Acquisition Strategy";
    diagNode.children = [
      node("Market", "hypothesis", "Is the target's market good?"),
      node("Target", "hypothesis", "Is the company healthy?"),
      node("Synergies", "hypothesis", "1+1=3?", [
        node("Cost Savings", "hypothesis"),
        node("Revenue Boost", "hypothesis")
      ]),
      node("Risks", "hypothesis", "Culture/Regs")
    ];
  } else {
    // GENERIC / SCQA DEFAULT
    diagNode.label = "Analysis (Why?)";
  }

  // 2a. Hypotheses from SCQA
  if (scqa.hypotheses && scqa.hypotheses.length) {
    scqa.hypotheses.forEach(h => {
      diagNode.children.push(node(`Hypothesis`, "hypothesis", h.h));
    });
  }
  // 2a.ii Assertions (New)
  if (scqa.assertions && scqa.assertions.length) {
    scqa.assertions.forEach((a, i) => {
      diagNode.children.push(node(`Assertion`, "hypothesis", a));
    });
  }

  // 2b. Fishbone Categories (ALWAYS SHOW if populated)
  // We use deterministic IDs matching getAnalysisLeaves() in app.js
  if (MODEL.fishbone && MODEL.fishbone.categories.length) {
    MODEL.fishbone.categories.forEach((cat, i) => {
      if (cat.causes.length) {
        const catNode = node(cat.name, "hypothesis", "", cat.causes.map((c, j) => {
          const n = node(c, "hypothesis");
          n.id = `FB-${i}-${j}`; // Explicit ID for linking
          return n;
        }));
        diagNode.children.push(catNode);
      }
    });
  }

  // 2c. 5 Whys (Full Chain)
  if (fiveWhys.chain && fiveWhys.chain.some(w => w)) {
    const whyNode = node("5 Whys Analysis", "hypothesis", "Deep Dive", []);
    let currentParent = whyNode;
    // We need to link tasks to specific Whys? 
    // getAnalysisLeaves only exposed 5Y-ROOT.
    // Let's expose all Whys?
    // For now, let's just make the Root Cause have the ID.

    fiveWhys.chain.forEach((why, i) => {
      if (why) {
        const wNode = node(`Why #${i + 1}`, "hypothesis", why);
        currentParent.children.push(wNode);
        currentParent = wNode;
      }
    });

    if (fiveWhys.rootCause && fiveWhys.rootCause !== "Root cause placeholder") {
      const rc = node("Root Cause", "hypothesis", fiveWhys.rootCause);
      rc.id = "5Y-ROOT"; // Explicit ID
      currentParent.children.push(rc);
    }

    diagNode.children.push(whyNode);
  } else if (fiveWhys.rootCause && fiveWhys.rootCause !== "Root cause placeholder") {
    const rc = node("Root Cause", "hypothesis", fiveWhys.rootCause);
    rc.id = "5Y-ROOT";
    diagNode.children.push(rc);
  }

  root.children.push(diagNode);


  // BRANCH 3: SOLUTION (How?)
  // This maps the "Answer" and "Tasks"
  const solLabel = scqa.answer ? `Solution: ${scqa.answer.substring(0, 25)}...` : "Proposed Strategy";
  const solNode = node(solLabel, "solution", scqa.answer || "Proposed Strategy", []);

  // Recommendation Node (Explicit)
  if (scqa.answer) {
    solNode.children.push(node("Recommendation", "solution", scqa.answer));
  }

  // 5 Whys Fix Idea (Auto Solution)
  if (fiveWhys.fixIdea && fiveWhys.fixIdea !== "Fix idea placeholder") {
    solNode.children.push(node("Fix (from 5Ys)", "solution", fiveWhys.fixIdea));
    // Auto-create a task from the Fix Idea if it doesn't already exist
    const fixIdeaTaskExists = tasks.some(t => t.title.includes(fiveWhys.fixIdea));
    if (!fixIdeaTaskExists) {
      tasks.push({
        id: uid("T"),
        title: fiveWhys.fixIdea,
        status: "Not Started",
        priority: 2, // Default to P2 for auto-generated fix idea
        due: "",
        estimateMin: guessEffort(fiveWhys.fixIdea),
        impact: guessImpact(fiveWhys.fixIdea),
        confidence: 0.7,
        owner: "You",
        blockers: [],
        nextAction: "Implement the fix idea",
        doneDefinition: "Fix idea implemented and validated",
        narrative: "",
        report: "",
        story: "",
        score: {
          TW: clamp(Math.round(guessImpact(fiveWhys.fixIdea) * 10), 0, 10),
          CP: 0.0,
          SM: MODEL.scoringDefaults.SM,
          ESF: MODEL.scoringDefaults.ESF,
          QM: MODEL.scoringDefaults.QM,
          SF: MODEL.scoringDefaults.SF,
          BP: MODEL.scoringDefaults.BP,
          BPS: 0,
          APS: 0,
          SPS: 0
        },
        tags: guessTags(fiveWhys.fixIdea)
      });
    }
  }

  // Group Tasks by MECE buckets (Priority)
  const p1 = tasks.filter(t => t.priority === 1);
  const p2 = tasks.filter(t => t.priority === 2);
  const others = tasks.filter(t => t.priority > 2);

  if (tasks.length > 0) {
    if (p1.length) solNode.children.push(node("Must Do (P1)", "action", "Critical Path", p1.map(t2node)));
    if (p2.length) solNode.children.push(node("Should Do (P2)", "action", "Important", p2.map(t2node)));
    if (others.length) solNode.children.push(node("Backlog", "action", "Nice to have", others.map(t2node)));
  } else {
    solNode.children.push(node("Execution", "action", "No tasks defined yet"));
  }

  root.children.push(solNode);

  // BRANCH 4: GOVERNANCE (Constraints)
  if (scqa.constraints) {
    const cNode = node("Constraints", "constraint", "Boundary Conditions", []);
    const c = scqa.constraints;
    if (c.time) cNode.children.push(node("Time", "constraint", c.time));
    if (c.budgetUSD) cNode.children.push(node("Budget", "constraint", `$${c.budgetUSD}`));
    if (c.quality) cNode.children.push(node("Quality", "constraint", c.quality));
    if (c.stakeholders && c.stakeholders.length) {
      cNode.children.push(node("Stakeholders", "constraint", c.stakeholders.join(", ")));
    }

    if (cNode.children.length) root.children.push(cNode);
  }

  return { root };

  function node(label, kind = "issue", note = "", children = []) {
    const cleanLabel = (label || "").replace(/"/g, "'");
    return { id: uid("N"), label: cleanLabel, kind, note, children };
  }

  function t2node(t) {
    return node(t.title, "task", `Due: ${t.due || "TBD"}`);
  }
}

/* ============================================================
   PRIORITIZATION (MoSCoW + Eisenhower)
   ============================================================ */

function computeTaskScore(task) {
  const TW = clamp(+task.score.TW || 0, 0, 10);
  const CP = clamp(+task.score.CP || 0, 0, 1);
  const SM = clamp(+task.score.SM || 1, 0.5, 2.0);
  const ESF = clamp(+task.score.ESF || 1, 0.5, 2.0);
  const QM = clamp(+task.score.QM || 1, 0.2, 2.0);
  const SF = clamp(+task.score.SF || 1, 0.5, 3.0);
  const BP = clamp(+task.score.BP || 0, 0, 0.8);

  const BPS = TW * CP;
  const APS = BPS * SM * ESF * QM;
  const SPS = APS * SF * (1 - BP);

  task.score.BPS = round2(BPS);
  task.score.APS = round2(APS);
  task.score.SPS = round2(SPS);
}
function round2(n) { return Math.round((+n || 0) * 100) / 100; }

function prioritizeTasks(tasks) {
  const ranked = tasks.map(t => {
    computeTaskScore(t);
    const tw = clamp(+t.score.TW || 0, 0, 10);
    const conf = clamp(+t.confidence || 0.6, 0, 1);
    const eff = Math.max(15, +t.estimateMin || 60);
    const urgency = dueUrgency(t.due);
    const value = (tw / 10) * conf / (eff / 120);
    const priorityScore = value * (1 + 0.4 * urgency);
    return { t, value, urgency, priorityScore };
  }).sort((a, b) => b.priorityScore - a.priorityScore);

  const n = ranked.length || 1;
  const cutMust = Math.max(1, Math.round(n * 0.25));
  const cutShould = Math.max(cutMust, Math.round(n * 0.60));
  const cutCould = Math.max(cutShould, Math.round(n * 0.90));

  const moscow = { must: [], should: [], could: [], wont: [] };
  ranked.forEach((x, i) => {
    const ref = refTask(x.t, x);
    if (i < cutMust) moscow.must.push(ref);
    else if (i < cutShould) moscow.should.push(ref);
    else if (i < cutCould) moscow.could.push(ref);
    else moscow.wont.push(ref);
  });

  const e = { ui: [], un: [], ni: [], nn: [] };
  tasks.forEach(t => {
    const urgent = dueUrgency(t.due) >= 1;
    const important = (t.priority ?? 9) <= 2 || (+t.score.TW || 0) >= 7;
    const label = `${t.id} — ${t.title}`;
    if (urgent && important) e.ui.push(label);
    else if (urgent && !important) e.un.push(label);
    else if (!urgent && important) e.ni.push(label);
    else e.nn.push(label);
  });

  return { moscow, eisenhower: e };
}
function dueUrgency(dueStr) {
  if (!dueStr) return 0;
  const now = Date.now();
  const due = new Date(dueStr + "T00:00:00").getTime();
  if (!Number.isFinite(due)) return 0;
  const days = (due - now) / 864e5;
  if (days <= 2) return 2;
  if (days <= 7) return 1;
  return 0;
}
function refTask(t, x) {
  const eff = Math.max(15, +t.estimateMin || 60);
  const tw = clamp(+t.score.TW || 0, 0, 10);
  const conf = clamp(+t.confidence || 0.6, 0, 1);
  const u = x.urgency;
  return `${t.id} — ${t.title} (TW ${tw}, conf ${Math.round(conf * 100)}%)`;
}

/* ============================================================
   GENERATORS
   ============================================================ */

/* ============================================================
   GENERATORS (ENHANCED)
   ============================================================ */

function genTaskNarrative(task, scqa) {
  const blockers = (task.blockers || []).length ? (task.blockers || []).join("; ") : "no immediate blockers";
  return `Objective: ${task.title}
Context: This effort addresses the conflict "${scqa.conflict.substring(0, 50)}...".
Plan: The next physical action is to ${task.nextAction || "clarify requirements"}.
Risk: Blockers include ${blockers}.
Success: Defined by "${task.doneDefinition || "completion of scope"}".`;
}

function genTaskReport(task) {
  return `TASK REPORT: ${task.id}
----------------------------------------
TITLE   : ${task.title}
STATUS  : ${task.status.toUpperCase()}
OWNER   : ${task.owner}
DUE     : ${task.due || "Not set"}

METRICS
----------------------------------------
SPS Score   : ${task.score.SPS} (Impact ${task.score.TW} x Completion ${task.score.CP})
Confidence  : ${Math.round((task.confidence || 0) * 100)}%
Effort Est  : ${task.estimateMin} min

EXECUTION
----------------------------------------
Next Action : ${task.nextAction || "TBD"}
Blockers    : ${(task.blockers || []).join(", ") || "None"}
`;
}

function genTaskStory(task, scqa) {
  return `The Hero (User) faces a problem: ${scqa.conflict}.
They try to achieve their goal, but ${task.blockers[0] || "constraints"} stand in the way.
Using the weapon of "${task.title}", they execute the move "${task.nextAction}".
The result is ${task.doneDefinition || "success"}, improving the situation significantly.`;
}

function genTaskComic(task) {
  return `PANEL 1
[Scene: A chaotic office or confused user]
Caption: "The problem seems impossible: ${task.title} is strictly needed."
Character: "We can't go on like this!"

PANEL 2
[Scene: The Hero working focused at a desk]
Caption: "Action taken: ${task.nextAction}"
Sound FX: *CLACK CLACK* (coding/working)

PANEL 3
[Scene: A green checkmark or happy stakeholder]
Caption: "Result: ${task.doneDefinition || "It works!"}"
Character: "Finally, progress!"`;
}

function genBrief(scqa, tasks) {
  const topRisks = tasks.filter(t => t.confidence < 0.5).map(t => t.title).slice(0, 3);
  const topGoals = tasks.filter(t => t.priority === 1).map(t => t.title).slice(0, 3);

  return `EXECUTIVE BRIEF
==================================================
SITUATION
${scqa.situation}

CRITICAL CONFLICT
${scqa.conflict}

STRATEGIC GOALS (Top P1s)
${topGoals.map(g => "- " + g).join("\n") || "- Define P1 tasks"}

KEY RISKS (Low Confidence)
${topRisks.map(r => "- " + r).join("\n") || "- None identified"}

RECOMMENDATION
${scqa.answer}
`;
}

function genMeeting(scqa, tasks) {
  // Mock slide deck structure
  const total = tasks.length;
  const done = tasks.filter(t => t.status === "Done").length;
  const progress = total ? Math.round((done / total) * 100) : 0;

  return [
    { title: "Executive Review", subtitle: nowStr() },
    { title: "Agenda", points: ["Status Check", "Key Blockers", "Decisions Needed"] },
    { title: "Health Check", points: [`Progress: ${progress}%`, `Tasks: ${total}`, `Risks: ${tasks.filter(t => t.confidence < 0.5).length}`] },
    { title: "Top Priority", points: tasks.filter(t => t.priority === 1).slice(0, 3).map(t => t.title) },
    { title: "Next Steps", points: ["Approve Plan", "Unblock Team"] }
  ];
}

function genCaseReport(scqa, fiveWhys, fishbone, priorities, tasks, meceTree) {
  scqa = scqa || MODEL.scqa || {};
  fiveWhys = fiveWhys || MODEL.fiveWhys || {};
  fishbone = fishbone || MODEL.fishbone || { categories: [] };
  priorities = priorities || MODEL.priorities || { moscow: { must: [], should: [], could: [], wont: [] }, eisenhower: { ui: [], un: [], ni: [], nn: [] } };
  tasks = tasks || MODEL.tasks || [];
  meceTree = meceTree || MODEL.meceTree || {};

  const rawInput = MODEL.rawInput || { contextText: "", tasksText: "" };
  const outputs = MODEL.outputs || {};
  const definitions = MODEL.definitions || [];
  const claims = MODEL.claims || [];

  const c = scqa.constraints || {};
  const stakeholders = (c.stakeholders || []).join(", ") || "N/A";
  const hypotheses = (scqa.hypotheses || [])
    .map((h, i) => `H${i + 1} (${Math.round((h.confidence || 0) * 100)}%): ${h.h}`)
    .join("\n") || "- None";
  const assertions = (scqa.assertions || []).map((a, i) => `A${i + 1}: ${a}`).join("\n") || "- None";
  const whys = (fiveWhys.chain || []).filter(Boolean).map((w, i) => `${i + 1}. ${w}`).join("\n") || "- Not set";
  const fishboneText = (fishbone.categories || []).length
    ? fishbone.categories.map(cat => {
      const causes = (cat.causes || []).join("; ") || "N/A";
      return `${cat.name}: ${causes}`;
    }).join("\n")
    : "- Not set";

  const scored = tasks.map(t => ({ t, sps: +t.score?.SPS || 0 }))
    .sort((a, b) => b.sps - a.sps);
  const topTasks = scored.slice(0, 10).map(({ t, sps }) => {
    const due = t.due || "TBD";
    const pri = t.priority ?? 3;
    const status = t.status || "Not Started";
    const owner = t.owner || "Unassigned";
    return `- ${t.id} ${t.title} (P${pri}, SPS ${sps}, ${status}, due ${due}, owner ${owner})`;
  }).join("\n") || "- None";

  const total = tasks.length;
  const done = tasks.filter(t => String(t.status || "").toLowerCase() === "done").length;
  const avgSps = total ? round2(scored.reduce((sum, x) => sum + x.sps, 0) / total) : 0;

  const moscow = priorities.moscow || { must: [], should: [], could: [], wont: [] };
  const eisenhower = priorities.eisenhower || { ui: [], un: [], ni: [], nn: [] };
  const treeText = meceTree.root ? treeToText(meceTree.root) : "No tree.";

  const topTask = scored[0]?.t;
  const execFocus = topTask
    ? `Focus: ${topTask.title}\nNext Action: ${topTask.nextAction || "TBD"}\nBlockers: ${(topTask.blockers || []).join(", ") || "None"}\nDoD: ${topTask.doneDefinition || "TBD"}`
    : "No task selected.";

  const rawContext = clipText(rawInput.contextText, 600);
  const rawTasks = clipText(rawInput.tasksText, 600);
  const meetingDeck = Array.isArray(outputs.meeting)
    ? outputs.meeting.map((s, i) => {
      const points = (s.points || []).join("; ");
      const subtitle = s.subtitle ? ` - ${s.subtitle}` : "";
      const body = points ? `: ${points}` : "";
      return `${i + 1}. ${s.title}${subtitle}${body}`;
    }).join("\n")
    : (outputs.meeting || "N/A");

  return `CASE REPORT
Generated: ${nowStr()}

EXECUTIVE SUMMARY
- Situation: ${textOr(scqa.situation, "N/A")}
- Conflict: ${textOr(scqa.conflict, "N/A")}
- Answer: ${textOr(scqa.answer, "N/A")}
- Top Task: ${topTask ? topTask.title : "N/A"}

PHASE 0 - DEFINITIONS AND CLAIMS
Definitions:
${definitions.length ? definitions.map((d, i) => `- ${i + 1}. ${d}`).join("\n") : "- None"}
Claims:
${claims.length ? claims.map((d, i) => `- ${i + 1}. ${d}`).join("\n") : "- None"}

RAW INPUT
Context:
${rawContext || "N/A"}
Tasks:
${rawTasks || "N/A"}

SCQA
Situation: ${textOr(scqa.situation, "N/A")}
Conflict: ${textOr(scqa.conflict, "N/A")}
Question: ${textOr(scqa.question, "N/A")}
Answer: ${textOr(scqa.answer, "N/A")}

CONSTRAINTS AND STAKEHOLDERS
Time: ${c.time || "N/A"}
Quality: ${c.quality || "N/A"}
Quantity: ${c.quantity || "N/A"}
Budget: ${c.budgetUSD || "N/A"}
Stakeholders: ${stakeholders}

HYPOTHESES
${hypotheses}

ASSERTIONS
${assertions}

FIVE WHYS
${whys}

ROOT CAUSE
${textOr(fiveWhys.rootCause, "N/A")}

FIX IDEA
${textOr(fiveWhys.fixIdea, "N/A")}

FISHBONE
${fishboneText}

STRUCTURAL MAP (TEXT)
${treeText}

PLAN AND PRIORITIES
MoSCoW:
  Must: ${(moscow.must || []).join(" | ") || "N/A"}
  Should: ${(moscow.should || []).join(" | ") || "N/A"}
  Could: ${(moscow.could || []).join(" | ") || "N/A"}
  Wont: ${(moscow.wont || []).join(" | ") || "N/A"}
Eisenhower:
  Urgent+Important: ${(eisenhower.ui || []).join(" | ") || "N/A"}
  Urgent+Not: ${(eisenhower.un || []).join(" | ") || "N/A"}
  Not Urgent+Important: ${(eisenhower.ni || []).join(" | ") || "N/A"}
  Not Urgent+Not: ${(eisenhower.nn || []).join(" | ") || "N/A"}

TASKS (TOP BY SPS)
${topTasks}

EXECUTION FOCUS
${execFocus}

OUTPUTS
Narrative:
${textOr(outputs.narrative, "N/A")}

Report:
${textOr(outputs.report, "N/A")}

Story:
${textOr(outputs.story, "N/A")}

Comic:
${textOr(outputs.comic, "N/A")}

Executive Brief:
${textOr(outputs.brief, "N/A")}

Meeting Deck:
${meetingDeck}

SCORE SUMMARY
Total Tasks: ${total}
Done: ${done}
Average SPS: ${avgSps}
`;

  function textOr(value, fallback) {
    const v = String(value || "").trim();
    return v ? v : fallback;
  }

  function clipText(value, maxChars) {
    const v = String(value || "").trim();
    if (!v) return "";
    if (v.length <= maxChars) return v;
    return v.slice(0, maxChars - 3) + "...";
  }
}

function treeToText(root) {
  const lines = [];
  (function walk(node, depth) {
    const indent = "  ".repeat(depth);
    lines.push(`${indent}- ${node.label}`);
    (node.children || []).forEach(child => walk(child, depth + 1));
  })(root, 0);
  return lines.join("\n");
}

function buildFishbone(scqa) {
  const c = (scqa.conflict || "").toLowerCase();

  // Heuristic categories
  const causes = {
    "People": ["Skills gap", "Bandwidth"],
    "Process": ["Workflow undefined", "Approvals"],
    "Tech": ["Legacy debt", "Performance"],
    "Data": ["Missing metrics", "Inconsistent"],
    "Culture": ["Resistance", "Silos"]
  };

  // Keyword injection
  if (c.includes("slow") || c.includes("crash")) causes["Tech"].push("Latency/Bug");
  if (c.includes("team") || c.includes("staff")) causes["People"].push("Morale/Training");
  if (c.includes("budget") || c.includes("cost")) causes["Process"].push("Funding");
  if (c.includes("unknown") || c.includes("opaque")) causes["Data"].push("Visibility");

  return {
    categories: Object.entries(causes).map(([name, items]) => ({ name, causes: items }))
  };
}

/* ============================================================
   PIPELINE
   ============================================================ */

function runPipeline() {
  runParseInput();
  runGeneration();
}

function runParseInput() {
  // Parse SCQA from Raw Input
  // Note: We only overwrite SCQA if Raw Input exists/changed. 
  // Ideally we should respect manual edits if they are "newer".
  // For now, let's assume if runPipeline is called, we want to re-parse.
  if (MODEL.rawInput.contextText) {
    MODEL.scqa = parseContextToSCQA(MODEL.rawInput.contextText);
  }

  // Parse Tasks
  if (MODEL.rawInput.tasksText) {
    MODEL.tasks = parseTasks(MODEL.rawInput.tasksText);
    MODEL.tasks.forEach(t => computeTaskScore(t));
  }
}

function runGeneration() {
  // Build 5 whys from SCQA (whether parsed or manually edited)
  // Only rebuild chians if empty or we want to force refresh?
  // Let's assume we rebuild dynamic parts but keep user edits if possible?
  // Current buildFiveWhysFromSCQA resets chain. 
  // Enhancement: Preserve non-empty user edits?
  // For now, let's just rebuild to be "Reactive". User can edit after.
  const fw = buildFiveWhysFromSCQA(MODEL.scqa);
  // Combine new defaults with existing user edits?
  // Logic: If user edited a "Why", keep it?
  // Complexity: High. Let's simple overwrite for "Generative" mode.
  MODEL.fiveWhys.chain = fw.chain;
  MODEL.fiveWhys.rootCause = fw.rootCause;
  MODEL.fiveWhys.fixIdea = fw.fixIdea;

  // Build tree
  MODEL.meceTree = buildIssueTree(MODEL.scqa, MODEL.fiveWhys, MODEL.tasks);

  // Build fishbone
  MODEL.fishbone = buildFishbone(MODEL.scqa);

  // Prioritize
  MODEL.priorities = prioritizeTasks(MODEL.tasks);

  // Generate Global Outputs
  MODEL.outputs.brief = genBrief(MODEL.scqa, MODEL.tasks);
  MODEL.outputs.meeting = genMeeting(MODEL.scqa, MODEL.tasks);
  MODEL.outputs.caseReport = genCaseReport(MODEL.scqa, MODEL.fiveWhys, MODEL.fishbone, MODEL.priorities, MODEL.tasks, MODEL.meceTree);

  // Default Task Outputs
  const t0 = MODEL.tasks[0];
  if (t0) {
    t0.narrative = genTaskNarrative(t0, MODEL.scqa);
    t0.report = genTaskReport(t0);
    t0.story = genTaskStory(t0, MODEL.scqa);
    t0.comic = genTaskComic(t0);

    MODEL.outputs.narrative = t0.narrative;
    MODEL.outputs.report = t0.report;
    MODEL.outputs.story = t0.story;
    MODEL.outputs.comic = t0.comic;
  }

  MODEL._meta.lastRunAt = nowStr();
}
